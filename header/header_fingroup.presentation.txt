
Group Presentations in Mathematical Components

Overview
========
This file provides an infrastructure for working with **finitely presented groups**—groups defined via generators and relations—within the Mathematical Components (MathComp) library for Coq. It enables users to express group presentations using a readable, mathematical syntax and supports reasoning about group homomorphisms and isomorphisms arising from these presentations. The main goal is to formalize and manipulate finite group presentations in proofs, seamlessly connecting abstract presentations to concrete group instances in Coq.

Mathematical Objects and Their Formal Representation
====================================================

1. **Group Presentations**
   - *Mathematical notion*: A group presentation is a construction `[ x₁, ..., xₙ | r₁, ..., rₘ ]` describing a group generated by elements `xᵢ`, subject to relations `rⱼ` (equalities between products/composites of the generators and their inverses).
   - *Coq representation*: The generators and relations are described using an inductive syntax tree (`term`, `formula` datatypes) that models group expressions (products, inverses, exponents, commutators, conjugations). A custom parser (`group_presentation` entry) allows for mathematical-style notation.

2. **Expressions on Generators: `term`**
   - Represents group words built from generators and the neutral element via operations:
     - `Cst n` – the `n`th generator
     - `Idx` – the identity element (1)
     - `Inv t` – inverse of a term
     - `Exp t n` – exponentiation
     - `Mul t₁ t₂` – group multiplication
     - `Conj t₁ t₂` – conjugation
     - `Comm t₁ t₂` – commutator
   - The `eval` function processes such a term into an actual group element given a concrete list of generators.

3. **Relations: `formula`, `rel_type`**
   - *Formulas* are equalities between terms (`Eq2 s t`) or conjunctions thereof (`And ...`).
   - Relations can be sequences of such equalities, encoding the defining equations/relators for the group.

4. **Abstraction of Presentations: `type`**
   - Presentations are recursively defined: a generator, possibly with nested generators, terminating in formulas describing the relations.
   - The `Generator` constructor encapsulates binding a new generator, tracking its position, and extending the environment.

5. **Interpretation: Satisfaction and Realization**
   - The satisfaction relation (`sat`) connects an abstract presentation to a concrete group. Given a candidate group, it specifies whether there exists an assignment of group elements (generators) so that the relations hold and the subgroup generated by these images equals the group in question.
   - The main predicate for realization is `hom gT G p`, which expresses (boolean-valued) that the group `G` can be realized as a homomorphic image of the group defined by presentation `p`.
   - The intensional predicate `iso gT G p` (incarnated as `G \isog Grp p`) asserts that `G` is, in an abstract sense, isomorphic to the largest finite quotient of the presented group.

6. **Environments and Tuple Assignments**
   - An environment (`env`) tracks the current subgroup and current tuple of generator images during interpretation.
   - Existential quantification ranges over n-tuples of group elements, corresponding to possible assignments of abstract generators in the presentation.

Key Notational and Coding Conventions
=====================================

- **Custom Notation for Presentations**: The file introduces a custom notation and parser mimicking mathematical presentation notation. For example:
   - `G \homg Grp (x : y : r₁, r₂, ...)` asserts that group `G` is generated by the images of `x` and `y` satisfying relations `r₁, r₂, ...`.
   - "Relators" (relations to the identity) can be written with shorthand: `s` for `s = 1`, or `s = t = u` for chaining equalities.
   - Terms within presentations use standard group symbols: `*` (multiplication), `^-1` (inverse), `^+ n` (exponent), `^` (conjugation), `[~ x, y]` (commutator).

- **Semantics of Notation**:
   - The notation `\homg` yields a computable Boolean predicate—suitable for reflection and automated reasoning.
   - The notation `\isog` defines an intensional logical predicate ("Prop"), suitable even for groups whose finiteness or non-triviality is undecidable.

- **Scoping and Overloads**:
   - Notations are defined within the `group_scope` to avoid clashes with other algebraic structures.
   - The use of static overloading for custom notations ensures symbolically rich presentations, closely mirroring textbook mathematical syntax.

- **Syntactic Layering**:
   - The types and coercions are arranged so that formulas and relations can be written succinctly, without verbose constructors or wrapper functions.
   - The parsing and builder functions treat generator binding, relation chaining, and group terms with minimal syntactic overhead.

Auxiliary Lemmas and Theoretical Properties
===========================================
The latter part of the file offers lemmas establishing the logical relations among isomorphism, homomorphic image, and composition:
- `isoGrp_hom`: Isomorphism of G to the presented group implies G is a homomorphic image.
- `homGrp_trans`, `isoGrp_trans`: Transitivity properties for homomorphic images and isomorphisms.
- `eq_homGrp`: Homomorphic properties are preserved under group isomorphisms.
- `intro_isoGrp`: Characterizes isomorphism with respect to universality among homomorphic images.

These components enable modular, proof-oriented development over group presentations, supporting both constructive computation (with Booleans) and abstract mathematical reasoning.

Summary and Intended Usage
==========================
This file is an essential bridge between the *combinatorial* definition of groups via presentations and *concrete* finite group structures in Coq. Users can define, manipulate, and prove properties about groups given only a list of generators and relations. Its abstractions and notational devices support both algorithmic inquiries (e.g., checking whether a group is a homomorphic image of a presentation) and structural investigations (e.g., classifying all finite groups with a given presentation).

All coding and notation conventions are chosen to make the file’s definitions read like standard group theory, lowering the barrier for mathematicians and formalizers to encode and reason about group presentations in MathComp-Coq developments.
