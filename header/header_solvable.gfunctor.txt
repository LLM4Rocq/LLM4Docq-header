
Generic Characteristic Subgroup Functors in Finite Group Theory
================================================================

Purpose and Main Objective
--------------------------
This file formalizes the notion of "generic" characteristic subgroup functors for finite groups within the Coq proof assistant, using the Mathematical Components (MathComp) library. The main goal is to provide a flexible, abstract framework for reasoning about various constructions that assign, to each finite group `G`, a canonically associated subgroup of `G` in a way that behaves functorially with respect to group homomorphisms. Typical mathematical examples include constructions such as the center, commutator subgroup, or characteristic subgroups generated by certain operations. The module's approach centers around encoding such constructions as *object maps* and specifying properties (closure, continuity, functoriality, etc.) as structured interfaces.

Mathematical Structures and Concepts
------------------------------------

**1. Finite Groups (`finGroupType` and `{group gT}`):**
  - A finite group is any instance of the Coq type `finGroupType` from MathComp. A concrete finite group is represented as a subgroup `{group gT}` of a type `gT : finGroupType`.

**2. Object Maps (`object_map`):**
  - The core abstraction is `object_map`, a polymorphic function associating to any finite group type `gT` and subgroup `A : {set gT}` a subset `F gT A : {set gT}`. These functions act as “subgroup-valued functors,” mediating constructions like "assign to each group its commutator subgroup."
  - The file fixes the notation `%gF` (the `gFun_scope`) for object maps, allowing composition and combination (see conventions below).

**3. Operations on Object Maps:**
  - **Composition (`F1 \o F2`)**: Sequential application, i.e., `(F1 \o F2) G = F1 (F2 G)`. Represents the composition of two functors at the group level.
  - **Modulo (`F1 %% F2`)**: For groups, represents constructing the subgroup associated to `G/F2 G` and pulling it back along the quotient, i.e., `(F1 %% F2) G / F2 G = F1 (G / F2 G)`. This operation encapsulates passage to derived objects modulo a normal subgroup.

**4. Key Properties of Object Maps:**
  The following basic predicates———parameterized by an object map `F`———are formalized:

    - *group_valued*: For any group `G`, the image `F G` is a subgroup.
    - *closed*: For any group `G`, the subgroup `F G` is indeed contained in `G`.
    - *continuous* (Functoriality): For any group homomorphism φ from G to H, φ maps `F G` into `F (φ(G))`.
    - *iso_continuous*: The image property above holds specifically for group isomorphisms.
    - *pcontinuous*: Like continuity, but with respect to partial group homomorphisms (domain restriction).
    - *hereditary*: If `H ≤ G`, then `F G ∩ H ≤ F H`, i.e., the functorial subgroup respects intersection.
    - *monotonic*: If `H ≤ G`, then `F H ≤ F G` (monotonicity under inclusion).

Each of these properties aligns with familiar group-theoretic behaviors (e.g., the center is hereditary; the derived subgroup is monotonic).

**5. Structured Interfaces (`iso_map`, `map`, `pmap`, `mono_map`):**
  - To facilitate robust and modular reasoning, these properties are bundled into hierarchy structures:

    - `iso_map`: Encapsulates maps that are group_valued, closed, and iso_continuous.
    - `map`: Inherits from `iso_map` and adds `continuous`.
    - `pmap`: Inherits from `map` and ensures `hereditary` (full pcontinuous).
    - `mono_map`: Inherits from `map` and ensures `monotonic`.

These are implemented as Coq records, each with canonical coercions up the hierarchy and with notations for constructing and cloning instances based on various combinations of properties and evidence.

Key Conventions and Notations
-----------------------------

1. **Scopes and Notation:**
    - The `%gF` (`gFun_scope`) scope is designated for object maps and their operations, supporting easy notation overloading.
    - Functor composition and modulo are written as `F1 \o F2` and `F1 %% F2`, respectively.
    - Structured functor types are introduced with square-bracket notations (e.g., `[gFun by Fcont]` for continuous functors, `[pgFun by Fher]` for pcontinuous, etc.), enabling user-friendly creation and extension of structured functors.

2. **Interface and Instantiation:**
   - The file provides canonical instances for standard constructions, such as the identity and the trivial subgroup functors. Canonical structures enable automatic inference of functorial properties when combining or nesting functors (e.g., associativity, inheritance of properties).

3. **Lemma Naming and Documentation:**
   - The lemma names adhere to the pattern `gF...` or as property suffixes (`...F`) to indicate their association with functor operations.
   - Sectioning and import/export patterns follow MathComp conventions for encapsulation and reusability.

4. **Exporting and Module Usage:**
   - The main definitions and notations are packaged within the `GFunctor` submodule, but critical notations, coercions, and lemmas are exported for direct use.
   - Users are encouraged to interact with functor properties via the provided interfaces and notations rather than the underlying implementation details.

Intended Usage and Context
--------------------------
This file serves as an abstraction layer for developments in group theory where characteristic subgroup constructions are required to be parametric and structurally robust. It supports formalizations where functoriality, invariance under isomorphisms, and inheritance properties must all be tracked formally. Downstream code—dealing with centers, p-cores, commutator chains, or various characteristic series—can instantiate the provided frameworks to obtain proofs of invariance, monotonicity, or hereditary properties essentially "for free" through the compositional structure.

The module’s approach enables the definition, combination, and analysis of generic characteristic subgroup constructions with minimal duplication, straightforward extensibility, and maximal transfer of structural lemmas. The top-level context is a highly algebraic, category-flavored treatment of finite group theory within constructive type theory.

Summary Table
-------------

| Concept                | Coq Formalization                                 | Mathematical Meaning                              |
|------------------------|---------------------------------------------------|---------------------------------------------------|
| Finite group           | `gT : finGroupType`, `{group gT}`                 | Finite group, subgroup of a finite group          |
| Object map             | `forall gT, {set gT} -> {set gT}`                 | Functorial association of subgroup to group       |
| Continuous functor     | `continuous F`                                    | Image preserved under group morphisms             |
| Iso-continuous functor | `iso_continuous F`                                | Image preserved under isomorphisms                |
| Modulo operation       | `F1 %% F2`                                        | Subgroup associated to quotient and pulled back   |
| Monotonic              | `monotonic F`                                     | Inclusion of subgroups lifts under F              |
| Hereditary             | `hereditary F`                                    | Intersections preserved or well-behaved           |
| Structures (interfaces)| `iso_map`, `map`, `pmap`, `mono_map`              | Bundling of properties for robust reasoning       |

This comprehensive and modular algebraic interface is foundational for machine-checked finite group theory and enables further theory building and code documentation to directly refer to the terminology and patterns explained above.
