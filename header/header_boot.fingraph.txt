
Finite Graphs, Relations, and Orbits over Finite Types

Overview and Purpose
====================
This file formalizes the theory of finite graphs, binary relations, and iteration orbits on types with finitely many elements (finite types) in the Coq proof assistant. Its primary goal is to develop foundational notions and lemmas about graphs and relations, such as connectivity and transitive closures, and to analyze the structure of orbits under functions (iteration, cycles, etc.). The development is designed to be compatible with and exploit the features of the Mathematical Components (MathComp) library, but abstracts the basic graph and relation-theoretic machinery to be applicable to arbitrary finite types.

Central Mathematical Objects and Their Representations
=====================================================

* **Finite Type (`finType`)**: The base setting for all definitions is a type `T` equipped with decidable equality and finitely many elements. Such types are denoted as `finType` in MathComp. Coq ensures through typeclass mechanisms that finiteness arguments are internally tracked and can be used for exhaustive procedures or cardinality arguments.

* **Graphs as Edge Relations and Neighborhood Functions**:
  - **Edge Relation (`rel T`)**: A binary relation on `T`, represented as a function `T -> T -> bool` indicating the presence/absence of an edge between two elements.
  - **Graph Adjacency Function (`T -> seq T`)**: Equivalently, a graph can be described by a function mapping each vertex to its adjacency list (the list of its neighbors).
  - **Neighborhood Relation (`grel g`)**: For `g : T -> seq T`, the induced relation `[rel x y | y \in g x]` encodes the adjacency structure.
  - **Relation-Graph Conversion (`rgraph e`)**: Builds a graph as an adjacency function from a relation `e`, enumerating the neighbors of each vertex.

* **Path-Finding and Connectivity**:
  - **Depth-First Search (`dfs`)**: Implements DFS over a finite graph, parameterized by remaining recursion depth for termination and an accumulator list to track visited nodes.
  - **DFS Path Predicate (`dfs_path`)**: An inductive predicate expressing the existence of a path between two elements in a graph, avoiding a given set of visited nodes.
  - **Connectivity Predicate (`connect`)**: Given a relation `e`, `connect e x y` holds if and only if there is a finite (possibly empty) sequence of edges relating `x` to `y`, i.e., if `y` is reachable from `x` via `e`. This formalizes the reflexive transitive closure (RTC) of a relation.
  - **Symmetric Connection (`connect_sym`)**: The property that the RTC is symmetric (i.e., an equivalence relation), implying “connected components” are equivalence classes.
  - **Root and Roots (`root`, `roots`)**: Each connected component is assigned a canonical representative (“root”) via selection heuristics (`pick`). The predicate `roots e x` is true if `x` is a root of its component.
  - **Component Counting (`n_comp`)**: Computes the number of (RTC-induced) connected components in (a subset of) `T`. When restricted to symmetric relations over closed sets, it counts equivalence classes.
  - **Closed Sets and Closure**:
    - **Closed Set (`closed e a`)**: A subset `a` is called e-closed if it is stable by the relation `e`: for all `(x, y)` in `e`, `x` in `a` iff `y` in `a`.
    - **Closure (`closure e a`)**: Returns the minimal e-closed superset containing `a` (the union of components intersecting `a`).

* **Orbits under Endofunctions**:
  - **Functional Connection (`fconnect f`)**: The RTC of the graph generated by repeatedly iterating a function `f : T -> T` (i.e., the least relation containing the steps `x` to `f x` and closed under composition).
  - **Orbits and Related Notions**:
    - **Order (`order f x`)**: Size (cardinality) of the orbit of `x` under `f`.
    - **Orbit Sequence (`orbit f x`)**: Lists the distinct elements encountered under iteration of `f` from `x` up to its period.
    - **Orbit Index (`findex f x y`)**: The index in the orbit of `x` where `y` appears.
    - **Functional Inverse (`finv f`)**: Defined when `f` is injective, gives the unique preimage for each element, computed via iterated application up to the orbit’s order.
    - **Canonical Representative (`froot f x`)**: The root of the orbit containing `x`.
    - **Set of Roots (`froots f`)**: The set of all distinct roots (orbit representatives).
    - **Orbit Partition Counting (`fcard f a`)**: Counts the number of distinct orbits (classes) contained in an `f`-invariant subset `a`.
    - **Order Set (`order_set f n`)**: The set of elements whose orbit under `f` has exactly `n` elements.
    - **Cycle Predicate (`fcycle f p`)**: Predicate indicating that a given sequence repeatedly cycles through the function.

* **Adjunctions between Relations**:
  - **Relation Adjunction (`rel_adjunction`)**: Abstracts a “correspondence” between domains via a mapping `h` and relations `e`/`e'`, ensuring component structure is preserved and compatible.
  - **Functional Adjunction (`fun_adjunction`)**: Specialization for function-induced relations.

Key Notational and Coding Conventions
=====================================
- **Naming Conventions**:
  - Relations on `T` are usually named `e` (edge), adjacency functions `g` or adjacency lists `g : T -> seq T`.
  - Functions iterated for orbits are always of type `T -> T` and written as `f`.
  - Predicates on `T` are expressed by sets/indicator functions, with set membership written as `x \in a`.
  - The suffix `_mem` is appended to auxiliary variant definitions that take explicit memory predicates.
  - Notations such as `n_comp e a`, `closed e a`, and `closure e a` are aliases for the more general versions with explicit `{pred T}` argument.

- **RTC and Connectedness**:
  - All statements about connectivity are defined via the computed RTC, leveraging DFS algorithms for decidability and enumeration on finite types.
  - In symmetric settings, connectivity partitions the type into equivalence classes (“connected components”).
  - The root of each component is selected by a canonical “pick” operation and used to enumerate and count components.

- **Orbit Analysis and Functional Closure**:
  - Function orbits are modeled using the RTC of their associated step relation.
  - Most results about orbits (uniqueness, cardinality, cycle structure) require `f` to be injective on the domain of interest.
  - Finite type finiteness ensures orbit enumeration and cycle detection are effective and provide uniqueness/canonical representatives.
  - When considering cycles, uniqueness in the sequence and injectivity lead to convenient enumerative and structural properties.

- **Set Closure and Invariance**:
  - A set/subset is called “closed” if it is invariant under the edge relation or function (no new elements are introduced by following the relation).
  - “Closure” always denotes the minimal expansion of a set ensured by repeated application of the relation/function.

- **Sectioning Pattern**:
  - The file is organized into `Section`s parameterized by a finite type, a relation, or a function to modularize the development.
  - Notations and implicit arguments are heavily used to keep statements concise; most main objects and operations are modeled as Coq definitions, not as records or typeclasses, to allow flexible instantiation and specialization.

Interpretive Guidance for Code Chunks
=====================================
- Functions and lemmas dealing with `dfs`, `grels`, `connect`, and `root` relate to general graph connectivity and component analysis.
- Content about `orbit`, `order`, `fconnect`, and their injectivity and invariance properties analyze iteration under a function, cycling, and orbit counting.
- Statements involving “closure”, “closed”, or component counting (`n_comp`) address set invariants under relations and partitioning of the type.
- Definitions concerning "adjunction" formalize structural compatibilities between two graphs or functions via a mapping, ensuring connected components correspond under the mapping.
- Most properties assert equivalences between operational/algorithmic notions (e.g., via DFS or enumeration) and abstract mathematical properties (e.g., existence of paths, cycles, or invariance under permutations).

Scope and Applicability
=======================
This file is foundational within the MathComp ecosystem (and generally in formal finitary mathematics) for any development involving graphs, finite group actions, Markov chains, automata, or any situation where iteration, connectivity, and partitioning arise. Care has been taken to isolate finiteness assumptions, and to design operations and proofs that are constructive and computationally effective.

No prior familiarity with the particular codebase or MathComp idioms is required: all main objects correspond directly to classical graph and relation-theoretic concepts, and the notations attempt to match common mathematical usage as closely as possible.

