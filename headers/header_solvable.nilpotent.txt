
Nilpotent and Solvable Groups in Finite Group Theory

Overview
========
This Coq source file formalizes the foundational properties of nilpotent and solvable groups within the context of finite group theory, as developed in the Mathematical Components (MathComp) library. It introduces precise definitions, principal series constructions, and a suite of lemmas characterizing and relating nilpotency and solvability, along with their behavior under standard group-theoretical operations such as products, quotients, and morphisms.

The main goals are:
- To define nilpotent and solvable subgroups of a finite group and characterize them in terms of central and derived series.
- To establish relationships and closure properties for these classes of groups under common group constructions (e.g., products, quotients, morphisms).
- To provide notations and machinery making it possible to reason mechanically about the nilpotence class and central series of finite groups.

Mathematical Objects and Representations
========================================
1. **Finite Groups and Subgroups**
   - Every group in this file is a finite group, formalized as `finGroupType` in Coq (types representing finite groups).
   - Subgroups and sets of group elements are represented by `{group gT}` and `{set gT}` for some group type `gT`.
   - The group notation `[1 gT]` refers to the trivial subgroup.

2. **Nilpotent Groups**
   - **Definition**: A group `G` is *nilpotent* if, for every nontrivial normal subgroup `H` of `G`, the commutator `[~: H, G]` is a proper subgroup of `H`. Formally, this is encoded as a universal, Boolean-valued predicate for subgroups of `G`.
   - **Nilpotence Class**: The *nilpotence class* of `G`, denoted `nil_class G`, is the minimal integer `n` such that the `(n+1)`st term of the lower central series is trivial. If no such `n` with `n < |G|` exists, then `nil_class G` is set to `|G|`, the order of `G`. Thus, `G` is nilpotent if and only if `nil_class G < |G|`.

3. **Solvable Groups**
   - **Definition**: A group is *solvable* if all of its nontrivial subgroups have a derived subgroup that is a proper subgroup, making it possible to reduce the group to the trivial subgroup via iterated commutator subgroups (the derived series). The property is formalized as a universal Boolean predicate similar to the nilpotence condition.

4. **Lower Central Series**
   - The *lower central series* of a group `G` is a descending chain of subgroups, with `L_0(G) = G`, `L_1(G) = G`, and `L_{n+1}(G) = [~: L_n(G), G]`. This captures successively deeper layers of commutativity.
   - In the file, `'L_n(G)` denotes the nth term, computed by repeated application (`iter`) of the commutator with `G`.
   - Notationally, this is represented as `lower_central_at n G`, but rendered for readability as `’L_n(G)` within proofs and code.

5. **Upper Central Series**
   - The *upper central series* is an ascending chain of normal subgroups, with `Z_0(G) = 1` (trivial group), and each subsequent term adds in the preimage, under the quotient map, of the center of the quotient group.
   - Formally: `Z_0(G) = 1`, `Z_{n+1}(G) / Z_n(G) = Z(G / Z_n(G))`.
   - In this file, this is expressed as `upper_central_at n G`, or more succinctly as `’Z_n(G)`.

6. **Group Operations and Series Functors**
   - The code provides canonical structures making the terms of the series recognized as subgroups (`group_set`, `Group`) and establishes their standard properties (normality, characteristic property, etc.).
   - The `GFunctor` and related functorial structures provide machinery for handling these series as group-valued functors with suitable continuity or naturality properties under morphisms and quotients.

7. **Group Products**
   - The file provides results about central and direct products:
     - *Central Product (`*`)*: A subgroup generated by commuting subgroups.
     - *Direct Product (`x`)*: Product of subgroups with trivial intersection.
   - It establishes how lower and upper central series of such products relate to those of the individual factors.

Key Coding and Notational Conventions
=====================================
1. **Type and Scope Notations**
   - The prime-apostrophe notation (`’L_n(G)`, `’Z_n(G)`) is adopted for terms of the lower and upper central series, following the MathComp convention for named series.
   - The double-prime notation such as `G^`(n)` (derivative/derived subgroup) is used for the nth commutator subgroup.
   - Many theorems and definitions use Boolean predicates with square brackets (e.g., `[forall (G : {group gT}), ...]`) to facilitate reasoning in the SSReflect style, which leverages reflection between Boolean and propositional assertions.

2. **Argument Scope Declarations**
   - Arguments to major functions and predicates are made implicit where possible to allow concise, idiomatic usage in formal developments.
   - The `%_g` and `%_N` scope tags indicate arguments are meant to be interpreted as subgroups or setwise subsets.

3. **Series Indexing**
   - The lower central series is indexed starting from 1, while the upper central series starts from 0; this is a non-standard but explicit convention within the file.
   - Iteration constructs (`iter n f x`) are used to define deepening steps in the respective series.

4. **Closure Properties and Transfer**
   - Special attention is given to properties preserved under morphisms (homomorphisms), injective morphisms, and quotient maps.
   - Lemmas are methodically stated and named to reflect closure of the nilpotent and solvable properties under passage to subgroups, quotients, images, and products.

5. **Booleans and Reflections**
   - For each major property, Boolean definitions are supplied (rather than propositional ones), with accompanying reflection or equivalence lemmas bridging the Boolean and mathematical statements.
   - This leverages the SSReflect/MathComp style, facilitating automation, rewrite-based reasoning, and compatibility with Coq's tactic ecosystem.

6. **Canonical Structures**
   - Wherever possible, series and associated group operations are made instances of MathComp’s canonical structures (e.g., group, functor, isog).
   - This ensures that they compose naturally with the broader MathComp algebraic hierarchy.

Summary
=======
This file provides a thorough, formal framework for working with nilpotent and solvable finite groups inside Coq, including detailed definitions of their principal series and structural invariants, along with robust notations and proof principles for analyzing their behavior under group-theoretic constructions. The conventions adopted allow for seamless integration with the MathComp libraries and efficient, reflective proofs of core theorems and routines in computational group theory.

A reader familiar with higher-level mathematics but new to the codebase will be able to interpret code snippets about group-theoretic series, nilpotence, solvability, and canonical group-theoretical constructions within this uniform and well-documented notation and terminology.
