
(******************************************************************************)
(*      Algebraic Structure Hierarchies in Mathematical Components             *)
(*                                                                            *)
(* Overview                                                                    *)
(* ========                                                                    *)
(*                                                                            *)
(* This file is the foundational core of the Mathematical Components           *)
(* (“MathComp”) algebraic hierarchy, providing a uniform, scalable, and        *)
(* extensible framework for formalizing a wide range of ring-like algebraic    *)
(* structures in the Coq proof assistant. It establishes the definitions,      *)
(* notations, and basic theory for semi-rings, rings, modules, algebras, and   *)
(* fields, both commutative and non-commutative, and meticulously engineers    *)
(* the mutual relationships, morphisms, and substructure constructs among      *)
(* them.                                                                      *)
(*                                                                            *)
(* The purpose is to serve as a robust basis for formal developments in        *)
(* algebra, number theory, field theory, linear algebra, and related domains,  *)
(* supporting a wide range of constructive as well as classical mathematics.   *)
(* It also provides extensive support for morphisms (structure-preserving      *)
(* maps) and for reasoning about substructures, closedness properties, and     *)
(* reification of first-order algebraic formulae.                              *)
(*                                                                            *)
(* Mathematical Structures and Concepts                                        *)
(* =======================================                                    *)
(*                                                                            *)
(* 1. **Hierarchy of Algebraic Structures:**                                   *)
(*    - *Nmodule, Zmodule*: Additive monoids (Nmodule) and additive abelian    *)
(*      groups (Zmodule), with 0 and (+), and opposites.                       *)
(*    - *PzSemiRing / NzSemiRing*: Semirings and non-trivial semirings         *)
(*      (with 0, 1, addition, multiplication, two distributivities).           *)
(*      *Pz* prefixes indicate the structure may have zero-divisors; *Nz*      *)
(*      indicates 1 ≠ 0.                                                       *)
(*    - *PzRing / NzRing*: Non-commutative rings, which add an additive        *)
(*      inverse to the semi-ring structure.                                    *)
(*    - *Com...*: “Com” prefixes signal commutative multiplications in         *)
(*      rings/semi-rings.                                                     *)
(*    - *UnitRing / ComUnitRing*: (commutative) rings where units have         *)
(*      computable inverses.                                                  *)
(*    - *IntegralDomain, Field, DecidableField, ClosedField*:                  *)
(*      Specializations: integral domains, fields (with inverse for all        *)
(*      nonzero), fields where the first-order theory is decidable, and        *)
(*      algebraically closed fields.                                           *)
(*    - *Modules (Lmodule), Algebras (Lalgebra), SemiAlgebras                  *)
(*      (LSemiAlgebra), and their commutative/unit variants.*                  *)
(*                                                                            *)
(* 2. **Morphisms and Maps:**                                                  *)
(*    Structure-preserving functions between algebraic types are handled by    *)
(*    a rich hierarchy:                                                        *)
(*     - *Additive, RMorphism, Linear, LRMorphism*, etc.—for additive,         *)
(*       ring, linear, and algebra morphisms; including semilinear and         *)
(*       scalar-linear maps.                                                   *)
(*     - The interface system ensures combinability and composability and      *)
(*       canonically recognizes additive/linear/ring properties for writing    *)
(*       and rewriting.                                                        *)
(*                                                                            *)
(* 3. **Substructure and Closedness:**                                         *)
(*    For any structure (ring, module, etc.), the framework supports           *)
(*    defining subtypes satisfying closedness predicates (e.g., being closed   *)
(*    under addition, multiplication), and automatically derives induced       *)
(*    algebraic structure—e.g., subrings, submodules, subalgebras.             *)
(*                                                                            *)
(* 4. **Hierarchies of Predicates/Closedness:**                                *)
(*    Hierarchically organized predicates express closure under additive,      *)
(*    multiplicative, ring, module, and division operations. These include     *)
(*    nmod_closed, zmod_closed, mulr_closed, semiring_closed,                  *)
(*    subring_closed, scaler_closed, and more. These drive the                 *)
(*    well-formedness of substructure mixins and power the construction of     *)
(*    canonical subtypes.                                                      *)
(*                                                                            *)
(* 5. **Syntax, Notation, and Naming:**                                        *)
(*    Carefully chosen and strongly scoped notations lighten the formal load,  *)
(*    making formal statements close to mathematical practice (e.g.,           *)
(*    +%R, *%R, *:%R, a *: v, x ^+ n, n %:R, etc.) and supporting expressions *)
(*    for both structures and morphisms.                                       *)
(*    The `GRing` module collects the canonical structure, supporting both     *)
(*    qualified and — via opening — unqualified use for ease of proof          *)
(*    development.                                                             *)
(*                                                                            *)
(* 6. **Decidable First Order Theory:**                                        *)
(*    Formal encoding of terms and formulas as inductive datatypes, together   *)
(*    with syntax for quantifiers, equations, units, and their Boolean         *)
(*    evaluation under environments. This enables first-order reasoning,       *)
(*    quantifier elimination, and automated model finding in fields with       *)
(*    a decidable theory.                                                      *)
(*                                                                            *)
(* 7. **Parameterization and HB (Hierarchy-Builder):**                         *)
(*    The file makes extensive use of Hierarchy-Builder (HB), a system for     *)
(*    packaging algebraic structures, constructing canonical substructures,    *)
(*    and deriving morphism properties.                                        *)
(*                                                                            *)
(* 8. **Reification and Quantifier-elimination:**                              *)
(*    The syntax trees and mechanics for formula evaluation, DNF conversion,   *)
(*    and quantifier elimination are built into the hierarchy, providing a     *)
(*    foundation for tools such as quantifier elimination in algebraically     *)
(*    closed fields.                                                           *)
(*                                                                            *)
(* 9. **Cartesian Products and Functions:**                                    *)
(*    Instances for product types and function spaces, so that function types  *)
(*    (e.g., finite functions) and product types inherit algebraic structure   *)
(*    canonically from their codomain/component types.                         *)
(*                                                                            *)
(* 10. **Sublibrary Conventions and Extension Points:**                        *)
(*     Mixins and factories enable users or other libraries to extend the      *)
(*     hierarchy with new structures, new morphism classes, and new closure    *)
(*     properties and to benefit from automation in inference and writing      *)
(*     proofs.                                                                 *)
(*                                                                            *)
(* Key Conventions                                                            *)
(* ================                                                          *)
(*                                                                            *)
(* - **Scopes:**                                                              *)
(*   The `ring_scope` (delimiter `%R`) is the main scope for ring, module,     *)
(*   and algebra arithmetic notations. Several other scopes, e.g.,            *)
(*   `term_scope` (for reified formulas), are also declared.                   *)
(*                                                                            *)
(* - **Notation:**                                                            *)
(*   Notations such as +%R (addition), *%R (multiplication), *:%R (scalar      *)
(*   multiplication), n%:R (embedding naturals), x *+ n (iterated addition),   *)
(*   and x ^+ n (exponentiation) are overloaded via scopes and structures.     *)
(*   Parentheses, symbolic infixes, and operator-priority conventions closely  *)
(*   follow standard mathematical practice.                                    *)
(*                                                                            *)
(* - **Mixins, Factories, and Canonical Structures:**                         *)
(*   The building blocks of the hierarchy are declared via HB mixin records,   *)
(*   providing the necessary properties (axioms) for each level (e.g.,         *)
(*   distributivity for rings, associativity, inverses for units, etc.), and   *)
(*   factories bundle these to enable instantiations and extensions.           *)
(*                                                                            *)
(* - **Suffix Notation for Lemmas:**                                          *)
(*   Lemmas and properties are systematically named with suffixes indicating   *)
(*   the operation: 0 for zero, 1 for one, D for addition, N for opposite,     *)
(*   M for multiplication, V for inverse, X for exponentiation, Z for scalar   *)
(*   multiplication, and so on, enabling predictable lemma lookup and          *)
(*   rewriting patterns.                                                       *)
(*                                                                            *)
(* - **Morphisms and Named Interfaces:**                                       *)
(*   Curly-bracketed interface types `{rmorphism R -> S}`, `{linear U -> V}`   *)
(*   provide type-level recognition of morphisms; morphism properties (e.g.,   *)
(*   preservation of +, *, or scaling) are annotated by suffix-based lemmas    *)
(*   for rewriting and chaining.                                               *)
(*                                                                            *)
(* - **Substructure pattern:**                                                 *)
(*   Subtypes representing sub-objects (e.g., subrings, submodules) are        *)
(*   instantiated via HB's `[Sub... of U by <:]` notation (for derived         *)
(*   mixins), with closedness predicates ensuring proper inheritance.           *)
(*                                                                            *)
(* - **Reification of formulas:**                                              *)
(*   Mathematical expressions and formulas are encoded as inductive types,      *)
(*   with notations to conveniently express variables, constants, ring         *)
(*   operations, and quantifiers, and associated substitution and evaluation   *)
(*   mechanisms.                                                               *)
(*                                                                            *)
(* - **Compatibility and Noncommutativity:**                                   *)
(*   Both commutative and non-commutative variants are handled in parallel,    *)
(*   using names like `PzRing`/`ComPzRing`, and appropriate instances and      *)
(*   notations reflect their algebraic laws.                                   *)
(*                                                                            *)
(* - **MathComp and HB Import/Export conventions:**                            *)
(*   Use of explicit import/export to manage scope pollution and ensure        *)
(*   intended visibility of notations and structures.                          *)
(*                                                                            *)
(* Interpretation Guidelines                                                   *)
(* =========================                                                   *)
(*                                                                            *)
(* The entire file is constructed to allow modular, scalable, and viewpoint-   *)
(* independent reasoning about algebraic hierarchies—whether you want to       *)
(* prove a result in arbitrary rings, commutative rings, modules, or fields,   *)
(* the appropriate structure and their substructures/morphisms are             *)
(* canonically recognized and their basic algebraic laws and notations are      *)
(* uniformly available. Whenever you see a section, a `HB.mixin`, a property,  *)
(* or a lemma here, its intent is to be used as a building brick in            *)
(* higher-level mathematics, with strong automation, generic rewriting, and    *)
(* code scaling in mind.                                                       *)
(*                                                                            *)
(* When commenting or understanding a particular code chunk:                    *)
(*  - Identify its level (structure, morphism, subobject, closedness).         *)
(*  - Locate its role in the inheritance/join hierarchy.                       *)
(*  - Consult its notation and scope (e.g., is it a notational form, HB mixin, *)
(*    or lemma suffix).                                                        *)
(*  - See how it interacts with morphism/closedness machinery (additivity,     *)
(*    scalability, etc.)—often specialized variants are provided to enable      *)
(*    effective rewriting.                                                     *)
(*  - For decision procedures or reification, note which inductive             *)
(*    representation is in play (term, formula) and how evaluation/reflection  *)
(*    are combined.                                                            *)
(*                                                                            *)
(* This file is self-contained and can be extended or utilized to construct    *)
(* new algebraic structures, morphisms, and decision procedures, or to         *)
(* instantiate existing hierarchies for new mathematical domains.              *)
(******************************************************************************)
