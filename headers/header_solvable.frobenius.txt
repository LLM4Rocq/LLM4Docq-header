
Frobenius Groups

Overview
========
This file formalizes the theory of Frobenius groups in the Coq proof assistant, using the Mathematical Components (MathComp) library's group theory infrastructure. It defines the core concepts associated with Frobenius groups—subgroup actions, semidirect products, transitivity and regularity conditions, and testable predicates for group-theoretic properties. In addition to formal definitions, the file provides a set of basic results about Frobenius groups and a version of the classical Frobenius theorem concerning solution counts to certain group equations.

Purpose and Main Goals
======================
The main objective of this file is to capture and mechanize the algebraic structure and the defining properties of Frobenius groups and related notions. Key goals include:

- Providing effective (computable) and propositional definitions of Frobenius groups, their kernels, and their complements.
- Characterizing semiregular and "prime" actions of groups on subgroups.
- Bridging the classical action-theoretic definition of Frobenius groups (as permutation groups with regularity properties) and the structural definition (as a semidirect product of a kernel and a complement).
- Establishing lemmas that relate properties of subgroups in the Frobenius context (such as Hall subgroups, coprimality of orders, and normalizers).
- Introducing notation and effective predicates to reason conveniently about Frobenius group structure in later developments.

Mathematical Objects and Their Representation
=============================================

1. **Finite Groups and Subgroups**
   - All groups are assumed finite and are represented as `{group gT}` where `gT` is a finite group type (`finGroupType` in MathComp).
   - Subsets and subgroups are implemented as elements of `{set gT}` or `{group gT}`.

2. **Semidirect Product (`K ><| H`)**
   - An explicit Coq operation, used to describe groups whose underlying set is formed as a semidirect product of subgroups `K` and `H`.

3. **Actions and Orbits**
   - Group actions are given by elements of `{action gT &-> sT}`, where `gT` acts on a finite type `sT`.
   - Stabilizers, orbits, fixed point sets, and centralizers are fundamentally important and are written with notation such as `'C_K[x]` (the centralizer in `K` of `x`) or `'Fix_(S | to)[x]` (the set of points in `S` fixed by `x` under action `to`).

4. **Frobenius Groups**
   - Defined both structurally and via actions:
     - Structurally: A group `G` is a Frobenius group with kernel `K` and complement `H` if `G = K ><| H`, and `H` acts on `K` in a certain "semiregular" or "prime" manner.
     - Action-theoretically: `G` acting faithfully and transitively on a set, so that no nontrivial element fixes more than one point and `H` is the stabilizer of a point.
   - Several effective predicates capture different instantiations, such as `[Frobenius G = K ><| H]` (structure with kernel and complement), `[Frobenius G with kernel K]`, `[Frobenius G with complement H]`, and `[Frobenius G]` (exists H making G a Frobenius group).

5. **Normed TI-Subgroups (`normedTI`)**
   - A subgroup `A` is a normed TI-subgroup of `G` with normalizer `L` if `A` and its conjugates have trivial intersection and `L` is the normalizer of `A` in `G`. This is central to defining complements in Frobenius groups.

6. **Regularity Conditions on Actions**
   - `semiregular K H`: No nontrivial element of `H` commutes with a nontrivial element of `K` (i.e., action is semiregular).
   - `semiprime K H`: If an element of `K` centralizes any nontrivial element in `H`, then it centralizes all of `H`.

7. **Frobenius Actions and Has-Frobenius-Action**
   - `Frobenius_action G H S to` formalizes the classical permutation group definition: G acts on S faithfully and transitively, nontrivial elements fix at most one point, H is the stabilizer subgroup of some point.
   - `has_Frobenius_action` is the existence of some set and action realizing the above.

8. **Hall Subgroups, Coprimality, and Partitioning**
   - Hall subgroups (subgroups whose order and index are coprime) and order divisibility facts are established for kernels and complements of Frobenius groups.
   - Lemmas include results about partitions of G into conjugates or cosets and divisibility properties involving group orders.

Key Notational and Coding Conventions
=====================================

- **Notation Blocks:** Special square-bracket notations provide readable, concise predicates: e.g., `[Frobenius G = K ><| H]` for the Frobenius property with explicit kernel and complement; `[Frobenius G]` for general Frobenius groups; `[Frobenius G with complement H]`, etc.
- **Subgroup Operations:** Subgroup relations like `\subset` (subset), `\proper` (proper subset), and `:!=:` (nontrivial) use standard MathComp infix notation.
- **Group Operations:** Conjugation is written as `A :^ x`, and normalizer and centralizer notation use `'N_G(A)` and `'C_G[x]`.
- **Action Restrictions:** The `{in X, forall ...}` construct restricts statements to elements in a subset.
- **Booleans vs. Propositions:** Effective, computable predicates are encoded as booleans. When bridging to classical, non-decidable properties, reflection is used (`reflect`).
- **Proof Sections:** The file is organized so that basic definitions are introduced first (in a “Definitions” section), with properties and lemmas following, often grouped by subject (e.g., basic properties, invariance under group homomorphisms, and divisibility theorems).
- **Argument Scoping:** Implicit arguments and scopes (`Import GroupScope`) are used to minimize notation clutter and follow MathComp best practices.
- **Parameterization:** Sections are heavily parameterized over group types and specific subgroups, maintaining generality and reusability.

Interpretation in Broader Context
=================================
This file serves as the foundational formalization of the algebraic and permutation-theoretic characterization of Frobenius groups within the MathComp/Ssreflect ecosystem. It is intended to supply definitions and core lemmas upon which more advanced results—including character-theoretic proofs or classification theorems—can be built. All mathematical concepts are encoded so as to maximize computational reflection, undecidable (classical) concepts are explicitly marked, and all representations and notations are designed for maximal clarity, consistency, and compositionality within Coq formalizations.
